package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

var input string //буфер клавиатурного ввода

type Card struct { //Тип данных "Карта": имеет имя, стоимость в очках (value) и статус: 0 - в колоде, 1 - в руке игрока, 2 - в руке дилера
	name          string //имя
	status, value int    //статус, стоимость в очках
}

type game_status struct { //Содержит состояние игры: счёт, расположение карт и т.д.
	mu          sync.Mutex
	pl_score    int          //начальный счет игрока
	cp_score    int          //начальный счет дилера
	pl_aces     int          //количество тузов у игрока
	cp_aces     int          //количество тузов у дилера
	card_number int          //случайный номер для выбора карты из колоды
	card_name   string       //он же в виде текстовой строки для обращения к map
	ace         bool         //по умолчанию выбранная карта - не туз
	pl_finished bool         //ни одно из условий для завершения хода игрока ещё не наступило
	cp_finished bool         //ни одно из условий для завершения хода дилера ещё не наступило
	Deck        map[int]Card // Колода именованных карт. Имена цифровые, чтобы можно было выбрать карту по генератору случайных чисел
}

func (g *game_status) Pick(score int) (new_score, card_number int, ace bool) { //функция выбирает из колоды случайную карту, не находящуюся ни в чьей руке и добавляет её стоимость к счёту. Также функция собщает, является ли карта тузом
	status := 3 //по умолчанию, статус "ошибка"
	value := 0  //стоимость по умолчанию "ошибка"
	ace = false // по умолчанию выбранная карта - не туз
	g.mu.Lock()
	for status != 0 { //до выбора карты, не находящейся ни в чьей руке
		card_number = rand.Intn(52)         //случайный номер карты
		value = g.Deck[card_number].value   //стоимость карты
		status = g.Deck[card_number].status //статус карты
		if value == 11 {                    //если карта является тузом
			ace = true //возвращаем туз == ИСТИНА
		}
	}
	fmt.Println(g.Deck[card_number].name) //выводим на экран выбранную карту
	g.mu.Unlock()
	new_score = score + value          //прибавляем стоимость карты к счёту выбранного игрока
	return new_score, card_number, ace // возвращает обновлённый счёт
}

func (g *game_status) Gameover() string { //определяет результат игры, возвращая его в виде текстовой строки
	g.mu.Lock()
	if g.pl_score == g.cp_score { //счёт равный -> ничья
		return "draw"
	}
	if g.cp_score > 21 { //перебор у дилера -> игрок победил
		return "player win"
	}
	if g.cp_score > g.pl_score && g.cp_score < 22 { //счёт дилера выше чем у игрока, но ниже 22 -> компьютер победил
		return "computer win"
	}
	if g.cp_score < g.pl_score && g.pl_score < 22 { //счёт игрока выше чем у дилера, но ниже 22 -> игрок победил
		return "player win"
	}
	g.mu.Unlock()
	return "computer win" // перебор у игрока -> компьютер победил
}

func main() {

	g := game_status{ //Состояние игры, с объявлением начальных значений - счёта, количества тузов у игроков, состояния колоды и т.д.
		mu:          sync.Mutex{},
		pl_score:    0,     //начальный счет игрока
		cp_score:    0,     //начальный счет дилера
		pl_aces:     0,     //количество тузов у игрока
		cp_aces:     0,     //количество тузов у дилера
		card_number: 0,     //случайный номер для выбора карты из колоды
		card_name:   "",    //он же в виде текстовой строки для обращения к map
		ace:         false, //по умолчанию выбранная карта - не туз
		pl_finished: false, //ни одно из условий для завершения хода игрока ещё не наступило
		cp_finished: false, //ни одно из условий для завершения хода дилера ещё не наступило
		Deck: map[int]Card{ // Колода именованных карт. Имена цифровые, чтобы можно было выбрать карту по генератору случайных чисел
			1: {"he_02", 0, 2}, 2: {"he_03", 0, 3}, 3: {"he_04", 0, 4}, 4: {"he_05", 0, 5}, 5: {"he_06", 0, 6}, 6: {"he_07", 0, 7}, 7: {"he_08", 0, 8}, 8: {"he_09", 0, 9}, 9: {"he_10", 0, 10}, 10: {"he_jk", 0, 10}, 11: {"he_qn", 0, 10}, 12: {"he_kg", 0, 10}, 13: {"he_ac", 0, 11}, 14: {"sp_02", 0, 2}, 15: {"sp_03", 0, 3}, 16: {"sp_04", 0, 4}, 17: {"sp_05", 0, 5}, 18: {"sp_06", 0, 6}, 19: {"sp_07", 0, 7}, 20: {"sp_08", 0, 8}, 21: {"sp_09", 0, 9}, 22: {"sp_10", 0, 10}, 23: {"sp_jk", 0, 10}, 24: {"sp_qn", 0, 10}, 25: {"sp_kg", 0, 10}, 26: {"sp_ac", 0, 11}, 27: {"dm_02", 0, 2}, 28: {"dm_03", 0, 3}, 29: {"dm_04", 0, 4}, 30: {"dm_05", 0, 5}, 31: {"dm_06", 0, 6}, 32: {"dm_07", 0, 7}, 33: {"dm_08", 0, 8}, 34: {"dm_09", 0, 9}, 35: {"dm_10", 0, 10}, 36: {"dm_jk", 0, 10}, 37: {"dm_qn", 0, 10}, 38: {"dm_kg", 0, 10}, 39: {"dm_ac", 0, 11}, 40: {"cl_02", 0, 2}, 41: {"cl_03", 0, 3}, 42: {"cl_04", 0, 4}, 43: {"cl_05", 0, 5}, 44: {"cl_06", 0, 6}, 45: {"cl_07", 0, 7}, 46: {"cl_08", 0, 8}, 47: {"cl_09", 0, 9}, 48: {"cl_10", 0, 10}, 49: {"cl_jk", 0, 10}, 50: {"cl_qn", 0, 10}, 51: {"cl_kg", 0, 10}, 0: {"cl_ac", 0, 11}},
	}
	rand.Seed(time.Now().UnixNano()) //карты будут вытаскиваться в соответствии со сгенерированной случайной последовательностью

	fmt.Println("Type hit or stand") //ход игрока. Игроку доступны две команды: ЕЩЁ (hit) и СЕБЕ (stand)
	for !g.pl_finished {             //игрок завершит ход при вводе команды "СЕБЕ" ИЛИ в случае перебора (<21 очков)
		g.mu.Lock()
		fmt.Scanf("%s\n", &input) //ожидаем действие игрока
		if input == "hit" {       //игрок ввёл команду "ещё"
			fmt.Println("You picking the card:")
			g.mu.Unlock()
			g.pl_score, g.card_number, g.ace = g.Pick(g.pl_score) //новый счёт, карта, является ли карта тузом = Pick(счёт игрока на данный момент)
			g.mu.Lock()
			g.Deck[g.card_number] = Card{g.card_name, 1, 0} //присваиваем карте статус "в руке игрока" чтобы больше она не вытаскивалась
			if g.ace {                                      //если карта оказалась тузом:
				g.pl_aces++ // запомним, что у игрока +1 туз
			}
			if g.pl_score > 21 && g.pl_aces > 0 { //ситуация перебора: если у игрока остались тузы, которые можно объявить единицей, то
				g.pl_score -= 10 //уменьшаем очки на 10 и продолжаем
				g.pl_aces--      //мы использовали один туз для погашения перебора
			}
			fmt.Println("Your score is:", g.pl_score)
			if g.pl_score > 20 { //при счёте более 20 дальнейшее взятие карт невозможно
				g.pl_finished = true //автоматический переход хода
			}
			g.mu.Unlock()
		}
		if input == "stand" { //игрок ввёл команду "себе"
			g.pl_finished = true //переход хода по команде игрока
		}
	}

	fmt.Println("Ход дилера") //ход дилера

	for !g.cp_finished { //дилер завершит ход по достижении 18 очков ИЛИ в случае перебора (<21 очков)
		fmt.Println("I picking the card:")
		g.mu.Unlock()
		g.cp_score, g.card_number, g.ace = g.Pick(g.cp_score) //новый счёт, карта, является ли карта тузом = Pick(счёт дилера на данный момент)
		g.mu.Lock()
		g.Deck[g.card_number] = Card{g.card_name, 2, 0} //присваиваем карте статус "в руке дилера" чтобы она более не вытаскивалась
		if g.ace {                                      //если карта оказалась тузом:
			g.cp_aces++ // запомним, что у дилера +1 туз
		}
		if g.cp_score > 21 && g.cp_aces > 0 { //ситуация перебора: если у дилера остались тузы, которые можно объявить единицей, то
			g.cp_score -= 10 //уменьшаем очки на 10 и продолжаем
			g.cp_aces--      //мы использовали один туз для погашения перебора
		}
		fmt.Println("My score is:", g.cp_score)
		if g.cp_score > 16 { //счёт дилера достиг 17
			g.cp_finished = true //завершение игры
			g.mu.Unlock()
		}
	}
	fmt.Println(g.Gameover()) //вывод результата игры
}
